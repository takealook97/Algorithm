⏱️ W2. 알고리즘
=

## 1. LeetCode 1
- 배열의 인덱스를 2개 씩 뽑아 생성할 수 있는 임의의 수만큼 반복
- 임의의 수가 target과 일치할 시 해당하는 수를 만든 배열의 인덱스 2개를 리턴

## 2. LeetCode 7
- Integer.MAX_VALUE = 2147483647
- Integer.MIN_VALUE = -2147483648 (절대값 기준 1이 더 크다)
- boolean으로 check 변수를 만들어 주어 x가 양수일 경우 true, 음수일 경우 false
- 입력받은 정수 x를 num 변수에 문자로 넣어준 뒤 뒤에서부터 차례대로 스트링 빌더에 쌓는다.
- check을 통해 false일 경우 "-"를 붙여준다.

## 3. LeetCode 83
- current 변수에 노드의 헤드를 지정한다.
- current.next가 null이 될 경우가 리스트의 tail에 해당한다.
- 주어진 리스트는 sorted(= 오름차순 정렬된)이므로 현재의 노드와 다음의 노드가 같을 경우를 찾는다.
- 같을 경우 next를 건너뛰어서 next.next(다음의 다음)으로 이어줌으로써 삭제한다.


## 4. LeetCode 9
- 펠린드롬수
- boolean으로 check 변수를 만들어서 결과값을 담는다.
- 입력된 정수 x를 num이라는 스트링에 지정한다.
- num의 길이(몇자리 수인지)를 반으로 나누어 처음과 끝부터 가운데까지 한칸씩 확인하도록 한다.
- x의 자리수가 홀수일 경우 가장 가운데있는 숫자는 고려할 필요가없기에 num.length() / 2 를 해도 무방하다.
- 중앙을 기준으로 대칭으로 체크했을 때 다를 경우 check = false이다

## 5. LeetCode 14
- 접두사만 따지면 되는 문제이므로 StringBuilder를 통해 결과값을 담아준다.
- 배열의 길이가 0 이면 빈칸을 리턴하고, 1이면 그대로 리턴한다.
- 배열의 첫 단어를 기준으로 삼고 두번째부터 끝까지의 단어를 이와 비교한다.
- StringBuilder에 쌓인 알파벳의 개수가 배열의 가장 짧은 단어보다 길어지면 반복문을 탈출한다.
- Character를 앞부터 하나씩 모두 비교하여 모두 동일할 경우 StringBuilder에 쌓는다.

## 6. LeetCode 141
- ArrayList를 활용하여 리스트에 이미 쌓인 값인지 체크한다.
- 이미 쌓인 값일 경우 반복되는 리스트이기에 true를 리턴한다.
- head.next가 null일 경우 tail 노드이므로 반복되지 않는 리스트 이기에 false를 리턴한다.